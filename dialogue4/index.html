<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Dialogue 4 - Group formation &middot; Supplementary material
    
  </title>

  


  <!-- CSS -->
  <link rel="stylesheet" href="/socialpsychtutorial/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/socialpsychtutorial/favicon.png" />
<link rel="shortcut icon" href="/socialpsychtutorial/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</head>


  <body class="index">

    <div id="sidebar">
  <header>
    <h1 class="site-title">
      <a href="/socialpsychtutorial/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        Supplementary material
      </a>
    </h1>
    <p class="lead">Formalising verbal theories: A tutorial by dialogue</p>
  </header>
  <nav id="sidebar-nav-links">
  
  

  

  


  

  

  

  
    
      <a class="page-link "
          href="/socialpsychtutorial/">Welcome</a>
    
  

  
    
      <a class="page-link "
          href="/socialpsychtutorial/chapter2/">Math concepts and notation</a>
    
  

  
    
      <a class="page-link "
          href="/socialpsychtutorial/dialogue1/">Dialogue 1 - Inviting guests</a>
    
  

  
    
  

  
    
      <a class="page-link "
          href="/socialpsychtutorial/dialogue1_comparison/">Dialogue 1 - Comparing models</a>
    
  

  
    
      <a class="page-link  active"
          href="/socialpsychtutorial/dialogue4/">Dialogue 4 - Group formation</a>
    
  

  
    
      <a class="page-link "
          href="/socialpsychtutorial/dialogue4_comparison/">Dialogue 4 - Comparing models</a>
    
  


  


  

  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/socialpsychtutorial/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  

  

  <!-- Optional additional links to insert for icons links -->
</nav>

  &#169; 2020, Mark Blokpoel and Iris van Rooij. This material has been released under a CC-BY 4.0 license and a GNU GPL v3 license. 

</div>

    <main class="container">
      <div class="content">
  


  <div id="toc-wrapper">
<ul id="markdown-toc">
  <li><a href="#party-subgrouping-v1" id="markdown-toc-party-subgrouping-v1">Party Subgrouping V1</a></li>
  <li><a href="#party-subgrouping-v2" id="markdown-toc-party-subgrouping-v2">Party Subgrouping V2</a></li>
</ul>

</div>

<div class="warning" style="max-width: 100%;background-color:#DF7777; color: #000; border-left: solid #a00000 4px; border-radius: 4px; padding-right: 2em;">
<span>
<p style="width: 100%;margin-top:1em; text-align:center">
<b>Interactive code offline</b></p>
<p style="width: calc(100% - 1em);margin-left: 1em;">
Due to the discontinuation of <a href="https://www.scalafiddle.com">www.scalafiddle.com</a>, the code blocks on this website are currently not interactive. We regret the limitations this imposes and are working on a solution.
</p></span>
</div>

<p>On this page you can find implementations of variants 1 and 2 of
<span style="font-variant: small-caps;">Party Subgrouping</span>. Included
are the formalizations themselves and the code to run a simulation for them.
You need to press the run button to run the simulation. This then also allows
you to change the input of the simulation to explore the behavior of the
models. You are encouraged to explore the simulations to your heartâ€™s content.
Afterwards, you can <a href="/socialpsychtutorial/dialogue4_comparison">compare the models through analysis here</a>.</p>

<h1 id="party-subgrouping-v1">Party Subgrouping V1</h1>

<p><span style="font-variant: small-caps;">Party Subgrouping (version 1)</span></p>

<p><em>Input:</em> A set of guests <script type="math/tex">G</script> and a function <script type="math/tex">sim: G \times G \rightarrow \mathbb{R}</script>.</p>

<p><em>Output:</em> A partition of <script type="math/tex">G</script> into non-overlapping subsets <script type="math/tex">G_1, G_2, ..., G_k</script> that maximizes average ingroup similarity:
<script type="math/tex">\frac{1}{k}\sum_{i=1,2,\dots k}sim(G_i)</script></p>

<p>Where ingroup similarity for subset <script type="math/tex">G_i</script> is defined as mean pair-wise similarity:
<script type="math/tex">sim(G_i)=\frac{1}{|G_i|}\sum_{g_i, g_j \in G_i} sim(g_i, g_j)</script></p>

<div data-scalafiddle="" data-template="Persons" data-minheight="1000" data-layout="v45">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ps1</span><span class="o">(</span><span class="n">G</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">sim</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">inGroupSim</span><span class="o">(</span><span class="n">subgroup</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
    <span class="nv">subgroup</span><span class="o">.</span><span class="py">uniquepairs</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">Function</span><span class="o">.</span><span class="py">tupled</span><span class="o">(</span><span class="n">sim</span><span class="o">)).</span><span class="py">sum</span> <span class="o">/</span> <span class="nv">subgroup</span><span class="o">.</span><span class="py">size</span><span class="o">.</span><span class="py">toDouble</span>

  <span class="nv">G</span><span class="o">.</span><span class="py">allPartitionings</span>
   <span class="o">.</span><span class="py">argMax</span><span class="o">(</span><span class="n">partitioning</span> <span class="k">=&gt;</span> <span class="o">{</span>
     <span class="nv">partitioning</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Gi</span> <span class="k">=&gt;</span> <span class="nf">inGroupSim</span><span class="o">(</span><span class="nc">Gi</span><span class="o">)</span> <span class="o">/</span> <span class="nv">partitioning</span><span class="o">.</span><span class="py">size</span><span class="o">).</span><span class="py">sum</span>
   <span class="o">})</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"A"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"B"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">c</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"C"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">d</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"D"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">e</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"E"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">G</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">similarities</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="mf">3.5</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="mf">4.0</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="o">)</span>
<span class="o">)</span>
<span class="k">def</span> <span class="nf">sim</span> <span class="k">=</span> <span class="nv">similarities</span><span class="o">.</span><span class="py">deriveFun</span>

<span class="k">val</span> <span class="nv">out</span> <span class="k">=</span> <span class="nf">ps1</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">sim</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">h2</span><span class="o">(</span><span class="s">"Input:"</span><span class="o">))</span>
<span class="nv">VegaRenderer</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">similarities</span><span class="o">.</span><span class="py">deriveGraph</span><span class="o">(</span><span class="n">G</span><span class="o">))</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">h2</span><span class="o">(</span><span class="s">"Output:"</span><span class="o">))</span>
<span class="nf">println</span><span class="o">(</span><span class="n">out</span><span class="o">)</span>

</code></pre></div></div>
</div>

<h1 id="party-subgrouping-v2">Party Subgrouping V2</h1>

<p><span style="font-variant: small-caps;">Party Subgrouping (version 2)</span></p>

<p><em>Input:</em> A set of guests <script type="math/tex">G</script>, a function <script type="math/tex">sim: G \times G \rightarrow \mathbb{R}</script>, and threshold of satisfactory similarity <script type="math/tex">s \in \mathbb{R}</script>.</p>

<p><em>Output:</em> A partition of <script type="math/tex">G</script> into non-overlapping subsets <script type="math/tex">G_1, G_2, ..., G_k</script> where each partition has satisfactory ingroup similarity:
<script type="math/tex">\forall_{i=1,2,\dots k}\left[sim(G_i) \geq s\right]</script></p>

<p>Where ingroup similarity for subset <script type="math/tex">G_i</script> is defined as mean pair-wise similarity:
<script type="math/tex">sim(G_i)=\frac{1}{|G_i|}\sum_{g_i, g_j \in G_i} sim(g_i, g_j)</script></p>

<div data-scalafiddle="" data-template="Persons" data-minheight="1000" data-layout="v45">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ps2</span><span class="o">(</span><span class="n">G</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">],</span>
        <span class="n">sim</span><span class="k">:</span> <span class="o">(</span><span class="kt">Person</span><span class="o">,</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Double</span><span class="o">,</span>
        <span class="n">s</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">]]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">inGroupSim</span><span class="o">(</span><span class="n">subgroup</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Person</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
    <span class="nv">subgroup</span><span class="o">.</span><span class="py">uniquepairs</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">Function</span><span class="o">.</span><span class="py">tupled</span><span class="o">(</span><span class="n">sim</span><span class="o">)).</span><span class="py">sum</span> <span class="o">/</span> <span class="nv">subgroup</span><span class="o">.</span><span class="py">size</span><span class="o">.</span><span class="py">toDouble</span>

  <span class="nv">G</span><span class="o">.</span><span class="py">allPartitionings</span>
   <span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">forall</span><span class="o">(</span><span class="nc">Gi</span> <span class="k">=&gt;</span> <span class="nf">inGroupSim</span><span class="o">(</span><span class="nc">Gi</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">))</span>
   <span class="o">.</span><span class="py">random</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"A"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"B"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">c</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"C"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">d</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"D"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">e</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"E"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">G</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">similarities</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="mf">3.5</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="mf">4.0</span><span class="o">),</span>
  <span class="nc">Similarity</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="o">)</span>
<span class="o">)</span>
<span class="k">def</span> <span class="nf">sim</span> <span class="k">=</span> <span class="nv">similarities</span><span class="o">.</span><span class="py">deriveFun</span>
<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="mf">2.5</span> <span class="c1">// If you get no valid output, try lowering this value.</span>

<span class="k">val</span> <span class="nv">out</span> <span class="k">=</span> <span class="nf">ps2</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">sim</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">h2</span><span class="o">(</span><span class="s">"Input:"</span><span class="o">))</span>
<span class="nv">VegaRenderer</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">similarities</span><span class="o">.</span><span class="py">deriveGraph</span><span class="o">(</span><span class="n">G</span><span class="o">))</span>
<span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"s=$s"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">h2</span><span class="o">(</span><span class="s">"Output:"</span><span class="o">))</span>
<span class="nf">println</span><span class="o">(</span><span class="n">out</span><span class="o">)</span>

</code></pre></div></div>
</div>



  

  

</div>
    </main>

    <!-- Optional footer content -->

  
<script>
  window.scalaFiddleTemplates = {

    'Persons': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)], weighted: Boolean = false) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@6?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@4?noext",\n              "vega": "vega@5?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line,\n    bin: Boolean = false): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType,\n          bin\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line,\n    bin: Boolean = false): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "title": "$title",\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal", "title": "$xLabel", "bin": ${if(bin) "true" else "false"}},\n            "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 40,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "title": "$xLabel", "type": "nominal", "spacing": 10, "bin": ${if(bin) "true" else "false"}\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": "label", "grid": false}},\n            "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "transform": [\n            {\n              "bin": ${if(bin) "true" else "false"},\n              "field": "$xValue",\n              "as": "bin_$xValue"\n            }\n          ],\n          "encoding": {\n              "x": {\n                "field": "${if(bin) "bin_"+xValue else xValue}",\n                "type": "ordinal",\n                "axis": {"format": ".2f", "titlePadding": 20},\n                "title": "$xLabel"\n              },\n              "color": {\n                "field": "label",\n                "type": "nominal",\n                "legend": {"orient": "bottom", "title": null}\n              }\n          },\n          "layer": [\n            {\n              "mark": {\n                  "type": "errorbar",\n                  "extent": "ci"\n              },\n              "encoding": {\n                "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"}\n              }\n            },\n            {\n              "mark": "${plotType.toString.toLowerCase}",\n              "encoding": {\n                "y": {\n                  "field": "$yValue",\n                  "aggregate": "mean",\n                  "type": "quantitative",\n                  "axis": {"format": ".2f", "titlePadding": 20},\n                  "title": "$yLabel"\n                }\n              }\n            }\n          ]\n          """\n        }\n      }\n  }.replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "${if(graph.weighted) "quantitative" else "nominal"}",\n                  "scale": {"scheme": "${if(graph.weighted) "viridis" else "set1"}"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def allPartitionings: Set[Set[Set[A]]] = {\n        if(set.isEmpty) Set.empty\n        else{\n          val hd = set.head\n          val solutions = set.tail.allPartitionings\n          val part1 = if(solutions.isEmpty) Set(Set(Set(hd)))\n          else solutions.map(partitioning => {\n            partitioning + Set(hd)\n          })\n          val part2 = if(solutions.isEmpty) Set(Set(Set(hd)))\n          else solutions.flatMap(partitioning => partitioning.map(part => {\n            val a = part + hd\n            val b = partitioning - part\n            b + a\n          }))\n          part1.union(part2)\n        }\n      }\n\n      def argMax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n\n      def argMaxOrElse(f: A => Double)(fallback: A): A = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) maxValSet(new Random().nextInt(maxValSet.length))._1 // if one or more maxima exist return random\n        else fallback\n      }\n\n      def random: Option[A] = if(set.isEmpty) None\n        else Some(set.toList(Random.nextInt(set.size)))\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n\n    def requirement(b: Boolean, msg: String): Unit =\n      if(!b) {\n        println(s"Requirement not met: $msg")\n        assert(false)\n      }\n  }\n\nimport Math._\nimport VegaRenderer._\n\ncase class Person(name: String) {\n  def like(other: Person): Relation = Relation(this, other, true)\n  def dislike(other: Person): Relation = Relation(this, other, false)\n\n  override def toString: String = name\n}\n\ncase object Person {\n    val names = List("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n    def random: Person = Person(names(Random.nextInt(names.length)))\n    def randomGroup(size: Int): Set[Person] = List.tabulate(size)(_ => Person.random).toSet\n}\n\ncase class Relation(a: Person, b: Person, liking: Boolean) {\n    def canEqual(a: Any) = a.isInstanceOf[Relation]\n\n    override def equals(that: Any): Boolean = that match {\n        case that: Relation => {\n            this.liking == that.liking && (this.a == that.a && this.b == that.b || this.a == that.b && this.b == that.a)\n        }\n        case _ => false\n    }\n}\n\ncase class Similarity(a: Person, b: Person, degree: Double) {\n  def canEqual(a: Any) = a.isInstanceOf[Relation]\n\n  override def equals(that: Any): Boolean = that match {\n      case that: Similarity => {\n          this.degree == that.degree && (this.a == that.a && this.b == that.b || this.a == that.b && this.b == that.a)\n      }\n      case _ => false\n  }\n}\n\nobject Helpers {\n  import Math._\n\n  implicit class ImplRelation(personA: String) {\n    def likes(personB: String): Relation = Relation(Person(personA), Person(personB), true)\n\n    def dislikes(personB: String): Relation = Relation(Person(personA), Person(personB), false)\n  }\n\n  implicit class ImplRelFun(relations: Set[Relation]) {\n    def deriveFun: ((Person, Person) => Boolean) = {\n      (a: Person, b: Person) => {\n        val rel = relations.find(p => p.a == a && p.b == b || p.a == b && p.b == a)\n        if(rel.isDefined) rel.get.liking\n        else false\n      }\n    }\n\n    def deriveGraph(persons: Set[Person]): Graph = {\n      val edges = for(p1 <- persons; p2 <- persons if p1 != p2) yield {\n        val col = if(deriveFun(p1, p2)) "likes" else "dislikes"\n        (p1, p2, col)\n      }\n      Graph(persons.toList, edges.toList)\n    }\n  }\n\n  implicit class ImplSimFun(similarities: Set[Similarity]) {\n    def deriveFun: ((Person, Person) => Double) = {\n      (a: Person, b: Person) => {\n        val sim = similarities.find(p => p.a == a && p.b == b || p.a == b && p.b == a)\n        if(sim.isDefined) sim.get.degree\n        else 0.0\n      }\n    }\n\n    def deriveGraph(persons: Set[Person]): Graph = {\n      val edges = for(p1 <- persons; p2 <- persons if p1 != p2) yield {\n        val col = deriveFun(p1, p2).toString\n        (p1, p2, col)\n      }\n      Graph(persons.toList, edges.toList, true)\n    }\n  }\n\n}\n\nimport Math._\nimport Helpers._\n\n',
      post: ''
    }
,

    'Persons': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)], weighted: Boolean = false) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@6?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@4?noext",\n              "vega": "vega@5?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line,\n    bin: Boolean = false): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType,\n          bin\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line,\n    bin: Boolean = false): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "title": "$title",\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal", "title": "$xLabel", "bin": ${if(bin) "true" else "false"}},\n            "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 40,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "title": "$xLabel", "type": "nominal", "spacing": 10, "bin": ${if(bin) "true" else "false"}\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": "label", "grid": false}},\n            "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "transform": [\n            {\n              "bin": ${if(bin) "true" else "false"},\n              "field": "$xValue",\n              "as": "bin_$xValue"\n            }\n          ],\n          "encoding": {\n              "x": {\n                "field": "${if(bin) "bin_"+xValue else xValue}",\n                "type": "ordinal",\n                "axis": {"format": ".2f", "titlePadding": 20},\n                "title": "$xLabel"\n              },\n              "color": {\n                "field": "label",\n                "type": "nominal",\n                "legend": {"orient": "bottom", "title": null}\n              }\n          },\n          "layer": [\n            {\n              "mark": {\n                  "type": "errorbar",\n                  "extent": "ci"\n              },\n              "encoding": {\n                "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"}\n              }\n            },\n            {\n              "mark": "${plotType.toString.toLowerCase}",\n              "encoding": {\n                "y": {\n                  "field": "$yValue",\n                  "aggregate": "mean",\n                  "type": "quantitative",\n                  "axis": {"format": ".2f", "titlePadding": 20},\n                  "title": "$yLabel"\n                }\n              }\n            }\n          ]\n          """\n        }\n      }\n  }.replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "${if(graph.weighted) "quantitative" else "nominal"}",\n                  "scale": {"scheme": "${if(graph.weighted) "viridis" else "set1"}"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def allPartitionings: Set[Set[Set[A]]] = {\n        if(set.isEmpty) Set.empty\n        else{\n          val hd = set.head\n          val solutions = set.tail.allPartitionings\n          val part1 = if(solutions.isEmpty) Set(Set(Set(hd)))\n          else solutions.map(partitioning => {\n            partitioning + Set(hd)\n          })\n          val part2 = if(solutions.isEmpty) Set(Set(Set(hd)))\n          else solutions.flatMap(partitioning => partitioning.map(part => {\n            val a = part + hd\n            val b = partitioning - part\n            b + a\n          }))\n          part1.union(part2)\n        }\n      }\n\n      def argMax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n\n      def argMaxOrElse(f: A => Double)(fallback: A): A = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) maxValSet(new Random().nextInt(maxValSet.length))._1 // if one or more maxima exist return random\n        else fallback\n      }\n\n      def random: Option[A] = if(set.isEmpty) None\n        else Some(set.toList(Random.nextInt(set.size)))\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n\n    def requirement(b: Boolean, msg: String): Unit =\n      if(!b) {\n        println(s"Requirement not met: $msg")\n        assert(false)\n      }\n  }\n\nimport Math._\nimport VegaRenderer._\n\ncase class Person(name: String) {\n  def like(other: Person): Relation = Relation(this, other, true)\n  def dislike(other: Person): Relation = Relation(this, other, false)\n\n  override def toString: String = name\n}\n\ncase object Person {\n    val names = List("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n    def random: Person = Person(names(Random.nextInt(names.length)))\n    def randomGroup(size: Int): Set[Person] = List.tabulate(size)(_ => Person.random).toSet\n}\n\ncase class Relation(a: Person, b: Person, liking: Boolean) {\n    def canEqual(a: Any) = a.isInstanceOf[Relation]\n\n    override def equals(that: Any): Boolean = that match {\n        case that: Relation => {\n            this.liking == that.liking && (this.a == that.a && this.b == that.b || this.a == that.b && this.b == that.a)\n        }\n        case _ => false\n    }\n}\n\ncase class Similarity(a: Person, b: Person, degree: Double) {\n  def canEqual(a: Any) = a.isInstanceOf[Relation]\n\n  override def equals(that: Any): Boolean = that match {\n      case that: Similarity => {\n          this.degree == that.degree && (this.a == that.a && this.b == that.b || this.a == that.b && this.b == that.a)\n      }\n      case _ => false\n  }\n}\n\nobject Helpers {\n  import Math._\n\n  implicit class ImplRelation(personA: String) {\n    def likes(personB: String): Relation = Relation(Person(personA), Person(personB), true)\n\n    def dislikes(personB: String): Relation = Relation(Person(personA), Person(personB), false)\n  }\n\n  implicit class ImplRelFun(relations: Set[Relation]) {\n    def deriveFun: ((Person, Person) => Boolean) = {\n      (a: Person, b: Person) => {\n        val rel = relations.find(p => p.a == a && p.b == b || p.a == b && p.b == a)\n        if(rel.isDefined) rel.get.liking\n        else false\n      }\n    }\n\n    def deriveGraph(persons: Set[Person]): Graph = {\n      val edges = for(p1 <- persons; p2 <- persons if p1 != p2) yield {\n        val col = if(deriveFun(p1, p2)) "likes" else "dislikes"\n        (p1, p2, col)\n      }\n      Graph(persons.toList, edges.toList)\n    }\n  }\n\n  implicit class ImplSimFun(similarities: Set[Similarity]) {\n    def deriveFun: ((Person, Person) => Double) = {\n      (a: Person, b: Person) => {\n        val sim = similarities.find(p => p.a == a && p.b == b || p.a == b && p.b == a)\n        if(sim.isDefined) sim.get.degree\n        else 0.0\n      }\n    }\n\n    def deriveGraph(persons: Set[Person]): Graph = {\n      val edges = for(p1 <- persons; p2 <- persons if p1 != p2) yield {\n        val col = deriveFun(p1, p2).toString\n        (p1, p2, col)\n      }\n      Graph(persons.toList, edges.toList, true)\n    }\n  }\n\n}\n\nimport Math._\nimport Helpers._\n\n',
      post: ''
    }

  }
</script>

<script defer src='https://embed.scalafiddle.io/integration.js'></script>
</body>
</html>
